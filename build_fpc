#!/bin/bash
set -euo pipefail

# ---------------------------------------------------------------------
# Build "best stable" FPC version from sources.
# The "best stable" means now:
# - 3.2.2
# - or 3.2.3 for some platforms (determined inside this script)
#
# Arguments:
# $1 is OS, $2 is CPU.
#
#   Must follow exactly FPC's naming convention for
#   - fpc -iTO / -iSO (target/source OS)
#   - fpc -iTP / -iSP (target/source CPU)
#   E.g. CPU is x86_64 (never x64).
#   E.g. OS is win64 or win32 (strictly depending on CPU architecture of Windows,
#   in contrast to some other conventions that may use "windows" or "win32"
#   for both 32-bit and 64-bit Windows).
#
#   They determine both source and target OS/CPU for the main compiler
#   we build. We build every compiler on its target platform, so source and target
#   are the same. This is also good for testing -- we can immediately execute
#   the compiler we build (see do_test).
#   ( Note that we can still build cross-compilers, this is unrelated. )
#
#   The given OS and CPU must correspond to the current platform,
#   since they describe both source (this) and target.
#   This means that usually you don't really have a choice in what
#   OS / CPU you provide: you must pass the one of the current system
#   (and we could also auto-detect it, in fact). But in some cases,
#   if platform can execute binaries with various architectures, you have
#   a choice. E.g. on Windows, you can pass either "win64 x86_64" or
#   "win32 i386" since it can execute (and build) FPC for either win32 or win64.
#
# Assumes:
# - We are in cge-fpc repository with bootstrap-fpc/ subdirectory available.
# - We have tools available, like standard Unix tools and git.
#   On Windows, be sure to have MSys2 (already OK on GH-hosted runners) or Cygwin.
# - We either have the bootstrap FPC binary in bootstrap-fpc/,
#   or ppc* binary available in PATH (and with correct version to bootstrap
#   the best stable FPC version here).
#
# This does almost all of the work of GitHub Actions workflow build.yml .
# Moving logic from YAML -> bash script makes it easier to:
#
# - Write multi-line bash stuff (otherwise you have to deal
#   with fact that Windows newlines are CRLF while bash (even on Windows)
#   requires LF, and workarounding it in YAML may involve fun with
#   https://yaml-multiline.info/ and >- and && ).
# - Debug on local machine. You can actually just run this script on your
#   local machine, and it should work equally well interactively.
# - No need for GHA specific tricks to define
#   environment variables using $GITHUB_ENV . Less reliance on GHA,
#   for when we move away from GitHub.
# - Easier to run from "ARM Runners" which require special setup in YAML,
#   but can then reuse this script.
#
# Output: fpc-*.zip file.
#
# Uses bash strict mode
# http://redsymbol.net/articles/unofficial-bash-strict-mode/
# ---------------------------------------------------------------------

# read params from command line
OS=$1
CPU=$2
shift 2

# ---------------------------------------------------------------------
# bash functions, do_xxx, to be executed in order to perform the script logic.

# Determine variables used through the rest of the script.
do_setup_environment ()
{
  # calculate WORKSPACE_ROOT and WORKSPACE_ROOT_UNIX.
  # On Windows they differ:
  # - WORKSPACE_ROOT_UNIX is in Cygwin path format (with /, without :, more suitable for $PATH)
  # - WORKSPACE_ROOT is in native (on Windows) path format, understood also by non-Msys2/Cygwin tools
  WORKSPACE_ROOT_UNIX="`pwd`"
  WORKSPACE_ROOT="${WORKSPACE_ROOT_UNIX}"
  if which cygpath > /dev/null; then
    WORKSPACE_ROOT="`cygpath --mixed \"${WORKSPACE_ROOT}\"`"
  fi

  # calculate ZIP_NAME
  ZIP_NAME="fpc-${OS}-${CPU}.zip"

  # calculate IS_UNIX, IS_WINDOWS (happen to be negation of each other now)
  if [ "${OS}" = "win64" -o "${OS}" = "win32" ]; then
    IS_UNIX=false
    IS_WINDOWS=true
  else
    IS_UNIX=true
    IS_WINDOWS=false
  fi

  # calculate NEEDS_FPC_FIXES_BRANCH
  if [ "${OS}" = "darwin" -o \
      '(' "${OS}" = "linux" -a "${CPU}" = "aarch64" ')' -o \
      '(' "${OS}" = "linux" -a "${CPU}" = "arm" ')' \
    ]; then

    # Build FPC 3.2.3 on macOS, to avoid failures like:
    #
    # """
    # Assembling rtti
    # rtl-objpas/units/x86_64-darwin/rtti.s:12:1: error: non-private labels cannot appear between .cfi_startproc / .cfi_endproc pairs
    # _$RTTI$_Lj102:
    # ^
    # rtl-objpas/units/x86_64-darwin/rtti.s:6:1: error: previous .cfi_startproc was here
    # """
    #
    # Fixed in FPC, see
    # https://github.com/LongDirtyAnimAlf/fpcupdeluxe/issues/745
    # https://gitlab.com/freepascal.org/fpc/source/-/commit/e749c81040070d3e8cb0c070e6e63f2f9b54fef4

    # Build FPC 3.2.3 on Linux/Arm or Aarc64 to avoid linking errors:
    #  (.text+0x54): undefined reference to `__libc_csu_init'
    # /usr/bin/ld: (.text+0x58): undefined reference to `__libc_csu_init'
    # /usr/bin/ld: (.text+0x5c): undefined reference to `__libc_csu_fini'
    # /usr/bin/ld: (.text+0x60): undefined reference to `__libc_csu_fini'

    local NEEDS_FPC_FIXES_BRANCH=true
  else
    local NEEDS_FPC_FIXES_BRANCH=false
  fi

  if [ "${NEEDS_FPC_FIXES_BRANCH}" = "true" ]; then
    FPC_BRANCHTAG="fixes_3_2"
    FPC_VERSION="3.2.3"
  else
    FPC_BRANCHTAG="release_3_2_2"
    FPC_VERSION="3.2.2"
  fi

  echo "Variables calculated:"
  echo "  ZIP_NAME (we will make this file): ${ZIP_NAME}"
  echo "  IS_UNIX: ${IS_UNIX}"
  echo "  IS_WINDOWS: ${IS_WINDOWS}"
  echo "  WORKSPACE_ROOT_UNIX: ${WORKSPACE_ROOT_UNIX}"
  echo "  WORKSPACE_ROOT: ${WORKSPACE_ROOT}"
  echo
  echo "  OS and CPU (source and target):"
  echo "  OS: ${OS}"
  echo "  CPU: ${CPU}"
  echo
  echo "  We will make such FPC:"
  echo "  NEEDS_FPC_FIXES_BRANCH: ${NEEDS_FPC_FIXES_BRANCH}"
  echo "  FPC_BRANCHTAG: ${FPC_BRANCHTAG}"
  echo "  FPC_VERSION: ${FPC_VERSION}"
}

# cleanup leftover files from previous runs
do_cleanup ()
{
  # Note: We should have a clean state anyway on GH-hosted runner,
  # and even self-hosted runner after clone,
  # but to enable all scenarios (including interactive testing,
  # and building win32 after win64 in same GHA job)
  # do the cleanup.
  rm -Rf fpcsrc/ fpc/ fpc-*.zip fpc-build-resources/
  mkdir -p fpc/
}

# get FPC sources to fpcsrc/
do_fpc_sources_get ()
{
  # Note: Using  -c advice.detachedHead=false just makes output shorter,
  # avoid useless warning (in this case, when we know what we do) about being
  # in "detached HEAD" state.

  git clone https://gitlab.com/freepascal.org/fpc/source.git \
    -c advice.detachedHead=false \
    --depth 1 --single-branch --branch "${FPC_BRANCHTAG}" fpcsrc
}

# Calculate $BOOTSTRAP_PPC_NAME , absolute filename of starting FPC binary.
do_calculate_bootstrap_ppc ()
{
  # calculate BOOTSTRAP_PPC_SUFFIX
  local BOOTSTRAP_PPC_SUFFIX
  case "${CPU}" in
    x86_64)  BOOTSTRAP_PPC_SUFFIX=ppcx64 ;;
    i386)    BOOTSTRAP_PPC_SUFFIX=ppc386 ;;
    aarch64) BOOTSTRAP_PPC_SUFFIX=ppca64 ;;
    arm)     BOOTSTRAP_PPC_SUFFIX=ppcarm ;;
    # More possible: ppc68k ppcppc ppcsparc ppcarmeb ppcppc64 ppcmips ppcmipsel ppcavr ppcjvm ppc8086 ppcsparc64
    *)
      echo "Precompiled FPC for bootstrap cannot be determined, cannot determine BOOTSTRAP_PPC_SUFFIX for this CPU: ${CPU}"
      exit 1
    ;;
  esac
  if [ "${IS_WINDOWS}" = "true" ]; then
    BOOTSTRAP_PPC_SUFFIX="${BOOTSTRAP_PPC_SUFFIX}.exe"
  fi
  echo "Bootstrap PPC suffix: ${BOOTSTRAP_PPC_SUFFIX}"

  # calculate BOOTSTRAP_PPC_NAME
  # Prepend to the binary name:
  # - source OS/CPU (from-....) since we must be able to execute it on this system
  # - required bootstrap version
  BOOTSTRAP_PPC_NAME="${WORKSPACE_ROOT}/bootstrap-fpc/3.2.2/from-${CPU}-${OS}/${BOOTSTRAP_PPC_SUFFIX}"
  echo "Bootstrap PPC full filename: ${BOOTSTRAP_PPC_NAME}"

  # fallback to system-wide ppc* if not found
  if [ ! -f "${BOOTSTRAP_PPC_NAME}" ]; then
    echo "Falling back to system-wide ${BOOTSTRAP_PPC_SUFFIX} binary."
    BOOTSTRAP_PPC_NAME="`which \"${BOOTSTRAP_PPC_SUFFIX}\"`"
    if which cygpath > /dev/null; then
      BOOTSTRAP_PPC_NAME="`cygpath --mixed \"${BOOTSTRAP_PPC_NAME}\"`"
    fi
    echo "Found system-wide ${BOOTSTRAP_PPC_SUFFIX} binary: ${BOOTSTRAP_PPC_NAME}"
  fi

  # check BOOTSTRAP_PPC_NAME exists
  # (later "make ..." call will also check it, but we prefer to check it earlier
  # and show clear error message on fail)
  if [ ! -f "${BOOTSTRAP_PPC_NAME}" ]; then
    echo "FPC binary to bootstrap not found: ${BOOTSTRAP_PPC_NAME}"
    exit 1
  fi

  # check BOOTSTRAP_PPC_NAME version
  # (later "make ..." call will also check it unless we use OVERRIDEVERSIONCHECK=1,
  # but then we should not need OVERRIDEVERSIONCHECK=1, we use the right version)
  local VALID_BOOTSTRAP_PPC_VERSION='3.2.2'
  local CURRENT_BOOTSTRAP_PPC_VERSION=`${BOOTSTRAP_PPC_NAME} -iV`
  if [ "$IS_WINDOWS" = 'true' ]; then
    # remove \r at the end, following https://superuser.com/questions/489180/remove-r-from-echoing-out-in-bash-script
    CURRENT_BOOTSTRAP_PPC_VERSION="${CURRENT_BOOTSTRAP_PPC_VERSION%%[[:cntrl:]]}"
  fi
  echo "Bootstrap PPC version is ${CURRENT_BOOTSTRAP_PPC_VERSION}."
  if [ "${CURRENT_BOOTSTRAP_PPC_VERSION}" != "${VALID_BOOTSTRAP_PPC_VERSION}" ]; then
    echo "Precompiled FPC for bootstrap has wrong version. Expected ${VALID_BOOTSTRAP_PPC_VERSION}, found ${CURRENT_BOOTSTRAP_PPC_VERSION}."
    exit 1
  fi
}

# calculate $FPC_OPTS which are used both for FPC building, and later to build
# test_program.lpr .
do_calculate_fpc_opts ()
{
  if [ "${OS}" = "darwin" ]; then
    # Following FpcUpDeluxe:
    # MacOS 10.14 Mojave and newer have libs and tools in new, yet non-standard directory
    FPC_OPTS='-XR/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk -Fl/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib -FD/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin'
  else
    FPC_OPTS=''
  fi
}

# Use this on Windows, around executing "make ..." with Makefile generated
# by FPCMake.
# Makefile generated by FPCMake has a few problems on Windows, unless it
# uses exactly the utilities as provided by FPC.
download_and_setup_fpc_build_resources ()
{
  # Makefile inside FPC has a few problems on Windows.
  #
  # Summary:
  # It's easiest to just avoid them by using utilities (like pwd.exe)
  # distributed by FPC (here we just reuse them from FPC 3.2.2 installation)
  # and relying they are placed in a directory without spaces (which is true
  # at least on GH-hosted Windows runners).
  # That's what we now do.
  #
  # Past problems and attempts:
  #
  # 1. At times, FPC Makefile wants native path (not MSys2/Cygwin path).
  #    This is understandable, but then they try to obtain it by looking for
  #    /cygdrive prefix and search+replace in Makefile, instead of using more
  #    reliable "cygpath --mixed ..." to convert paths. The latter would work
  #    on both MSys2 and Cygwin, and would work for all paths, e.g. /home/...
  #    (which doesn't start with /cygdrive but is still a Cygwin path).
  #
  #    Failing to solve it may result in "make ..." error, and FPC saying it cannot
  #    find unit system used by pp. You will see it is passing -Fu/cygwin/path
  #    to ppc*, and thus it's a Cygwin path.
  #
  # 2. Makefile inside FPC has problems when `pwd.exe` is present in a directory
  #    with space in path.
  #    The Makefile does PWD:=$(strip $(wildcard $(addsuffix /pwd,$(SEARCHPATH))))
  #    and will fail to find PWD when there is space in path.
  #    And this is the case on GH-hosted Windows runner, where pwd.exe
  #    is inside "C:/Program Files/Git/usr/bin/".
  #
  #    They could have used "which pwd", which would be more reliable, but didn't...
  #
  #    Symptom: "make ..." fails with "You need the GNU utils package to use this Makefile".
  #
  #    Solution is to use our ${WORKSPACE_ROOT_UNIX}/fpc-build-resources/install/binwXX .

  git clone https://gitlab.com/freepascal.org/fpc/build.git \
    -c advice.detachedHead=false \
    --depth 1 --single-branch --branch main fpc-build-resources

  # check the layout of fpc build repo on
  # https://gitlab.com/freepascal.org/fpc/build/-/tree/main/install?ref_type=heads
  local FPC_BUILD_OS_SUBDIR
  case "${CPU}" in
    x86_64) FPC_BUILD_OS_SUBDIR=binw64 ;;
    i386)   FPC_BUILD_OS_SUBDIR=binw32 ;;
    *)
      echo "Cannot find FPC_BUILD_OS_SUBDIR for this CPU: ${CPU}"
      exit 1
      ;;
  esac

  # Restore $PATH later, as the FPC utilities are weirdly old.
  # E.g. `mv.exe` is some archaic version that doesn't tolerate last
  # parameter having final slash (would fail at "mv ... fpc/bin/",
  # while the standard "mv" from both MSys2 (in GHA) and Cygwin can handle it).
  RESTORE_PATH="$PATH"

  # Note that we need to append here to PATH using WORKSPACE_ROOT_UNIX,
  # not WORKSPACE_ROOT, as in MSys/Cygwin, : is path separator
  # (not drive letter separator).
  export PATH="${WORKSPACE_ROOT_UNIX}/fpc-build-resources/install/${FPC_BUILD_OS_SUBDIR}/:$PATH"
}

do_fpc_build ()
{
  # Disable broken MSys2 paths conversion,
  # it can mess parameters that start with / ,
  # see https://github.com/castle-engine/castle-engine/blob/6caed57cadcdd9ff383df8028e4bb274ca17732b/.github/workflows/test-and-pack-runner-native.yml#L129
  export MSYS2_ENV_CONV_EXCL='*'

  # main building command
  local FPC_INSTALL_PREFIX="${WORKSPACE_ROOT}/fpc"

  if [ "${IS_WINDOWS}" = "true" ]; then
    download_and_setup_fpc_build_resources
  fi

  cd fpcsrc/
  make clean all install \
    INSTALL_PREFIX="${FPC_INSTALL_PREFIX}" \
    FPC=${BOOTSTRAP_PPC_NAME} \
    OPT="${FPC_OPTS}"

  if [ "${IS_WINDOWS}" = "true" ]; then
    export PATH="$RESTORE_PATH"
  fi

  # TODO: Enable cross-compiler to Win64 from other systems.
  # In the past this was making CGE pack_release job fail with "out of disk space"
  # but it should be fixed now. -- indeed FPC zips are larger.
  # TODO: Even better would be to have some way to auto-download FPC cross-compilers,
  # to not include them in the CGE release.
  # if [ "${OS}" != "win64" -o "${CPU}" != "x86_64" ]; then
  #   make crossall crossinstall OS_TARGET=win64 CPU_TARGET=x86_64 INSTALL_PREFIX="{FPC_INSTALL_PREFIX}" OPT="${FPC_OPTS}"
  # fi

  # TODO: Enable cross-compiler to macOS/Aarch64 from macOS/Intel.
  # if [ "${OS}" = "darwin" -a "${CPU}" = "x86_64" ]; then
  #   make crossall crossinstall OS_TARGET=darwin CPU_TARGET=aarch64 INSTALL_PREFIX="${FPC_INSTALL_PREFIX}" OPT="${FPC_OPTS}"
  # fi

  # back to main dir, with fpc/ and fpcsrc/ as subdirs
  cd ../
}

do_fix_layout ()
{
  # Make layout simple
  if [ "${IS_UNIX}" = "true" ]; then
    # Put ppc* (including and ppcross*), like ppcx64, in fpc/bin/, so that main fpc binary can find it easily
    mv -f fpc/lib/fpc/"${FPC_VERSION}"/ppc* fpc/bin/

    # Put units/ as subdirectory of main fpc/ -- this makes it simpler to refer to, and consistent with Windows layout
    mv -f fpc/lib/fpc/"${FPC_VERSION}"/units fpc/
  fi

  if [ "${IS_WINDOWS}" = "true" ]; then
    mv -f fpc/bin/"${CPU}-${OS}"/* fpc/bin/
    # Remove empty unneeded dir
    rm -R fpc/bin/"${CPU}-${OS}"/
  fi
}

# copy relevant sources from fpcsrc/ to fpc/src
do_copy_sources ()
{
  # Copy sources to fpc/src
  # See https://stackoverflow.com/questions/160608/do-a-git-export-like-svn-export
  # This way we only copy to fpc/src files from repo (not any compiled stuff,
  # and "make clean" doesn't really clean everything; and not .git subdir).
  cd fpcsrc/
  mkdir ../fpc/src
  git archive HEAD | tar -x -C ../fpc/src
  cd ../ # back to top-level
}

# pack to zip.
do_pack_zip ()
{
  if which 7z > /dev/null; then
    # Use 7z on Windows to make zip, as it's preinstalled on GH hosted Windows.
    # ( We could alternatively install zip, e.g. using Chocolatey,
    # or use PowerShell
    # "run: Compress-Archive -Path folder/ -Destination new.zip"
    # see https://stackoverflow.com/questions/74939762/create-zip-file-of-github-reporitory-using-a-workflow-which-runs-on-windows-lat )
    7z a ${ZIP_NAME} fpc/
  else
    zip -r ${ZIP_NAME} fpc/
  fi
}

# Test that build FPC (in fpc/ , which we assume we can just execute)
# returns correct version and OS/CPU.
do_test_version_os_cpu ()
{
  local ACTUAL_FPC_VERSION="`fpc/bin/fpc -iV`"
  if [ "$IS_WINDOWS" = 'true' ]; then
    # remove \r at the end, following https://superuser.com/questions/489180/remove-r-from-echoing-out-in-bash-script
    ACTUAL_FPC_VERSION="${ACTUAL_FPC_VERSION%%[[:cntrl:]]}"
  fi
  if [ "$ACTUAL_FPC_VERSION" != "$FPC_VERSION" ]; then
    echo "FPC version is $ACTUAL_FPC_VERSION, expected $FPC_VERSION"
    exit 1
  fi

  local ACTUAL_OS="`fpc/bin/fpc -iTO`"
  if [ "$IS_WINDOWS" = 'true' ]; then
    # remove \r at the end, following https://superuser.com/questions/489180/remove-r-from-echoing-out-in-bash-script
    ACTUAL_OS="${ACTUAL_OS%%[[:cntrl:]]}"
  fi
  if [ "$ACTUAL_OS" != "$OS" ]; then
    echo "FPC OS is $ACTUAL_OS, expected $OS"
    exit 1
  fi

  local ACTUAL_CPU="`fpc/bin/fpc -iTP`"
  if [ "$IS_WINDOWS" = 'true' ]; then
    # remove \r at the end, following https://superuser.com/questions/489180/remove-r-from-echoing-out-in-bash-script
    ACTUAL_CPU="${ACTUAL_CPU%%[[:cntrl:]]}"
  fi
  if [ "$ACTUAL_CPU" != "$CPU" ]; then
    echo "FPC CPU is $ACTUAL_CPU, expected $CPU"
    exit 1
  fi
}

# Test that build FPC (in fpc/ , which we assume we can just execute)
# can compile a simple program.
do_test_program ()
{
  fpc/bin/fpc \
    "-Fufpc/units/${CPU}-${OS}/*" \
    ${FPC_OPTS} \
    test_program.lpr

  local TEST_PROGRAM_OUTPUT="`./test_program`"
  if [ "$IS_WINDOWS" = 'true' ]; then
    # remove \r at the end, following https://superuser.com/questions/489180/remove-r-from-echoing-out-in-bash-script
    TEST_PROGRAM_OUTPUT="${TEST_PROGRAM_OUTPUT%%[[:cntrl:]]}"
  fi

  if [ "${TEST_PROGRAM_OUTPUT}" != "Hello World!" ]; then
    echo "Test program failed to execute correctly. Output: $TEST_PROGRAM_OUTPUT"
    exit 1
  fi
}

# ---------------------------------------------------------------------
# main: execute bash functions in order

do_setup_environment
do_cleanup
do_fpc_sources_get
do_calculate_bootstrap_ppc
do_calculate_fpc_opts
do_fpc_build
do_fix_layout
do_copy_sources
do_pack_zip
do_test_version_os_cpu
do_test_program
